// CRYENGINE Source Code File
// Copyright 2001-2015 Crytek GmbH. All rights reserved.


////////////////////////////////////////////////////////////////////////////
// Important Note:
//
// Wave occupancy is essential to get a performance benefit from tiled deferred shading.
// Branch heavy code can increase the number of VGPRs that are required to execute
// the shader which in turn will lower the wave occupancy.
// When modifying the shader code, please check in PIX on Xbox One that the occupancy is
// at least 3 for the tiled deferred shading pass.
//
////////////////////////////////////////////////////////////////////////////


// The following constants and structs have to match the engine code!!

#define TILED_SHADING_MAX_NUM_LIGHTS  255
#define TILED_SHADING_TILE_SIZE_X       8
#define TILED_SHADING_TILE_SIZE_Y       8

#define TILED_SHADING_SPECPROBE_MAXMIP  6

#define TILED_THREAD_GROUP_SIZE		TILED_SHADING_TILE_SIZE_X * TILED_SHADING_TILE_SIZE_Y

struct STiledLightCullInfo
{
	uint      volumeType;
	uint      PADDING0;
	float2    depthBounds;
	float4    posRad;
	float4    volumeParams0;
	float4    volumeParams1;
	float4    volumeParams2;
};

struct STiledLightVolumeVertex
{
	float3 position;
};

struct STiledLightVolumeInfo
{
	float4x4  worldMat;
	float4    volumeTypeInfo;
	float4    volumeParams0;
	float4    volumeParams1;
	float4    volumeParams2;
	float4    volumeParams3;
};

struct STiledLightShadeInfo
{
	uint      lightType;
	uint      resIndex;
	uint      shadowMaskIndex;
	uint      stencilID;
	float4    posRad;
	float2    attenuationParams;
	float2    shadowParams;
	float4    color;
	float4x4  projectorMatrix;
	float4x4  shadowMatrix;
};

struct STiledClipVolumeInfo
{
	uint		data; // bits 0-15 reserved for flags, 16-23 blendID1, 24-31 blendID0
};

#define TILEDLIGHT_VOLUME_SPHERE   1
#define TILEDLIGHT_VOLUME_CONE     2
#define TILEDLIGHT_VOLUME_OBB      3
#define TILEDLIGHT_VOLUME_SUN      4

#define TILEDLIGHT_TYPE_PROBE              1
#define TILEDLIGHT_TYPE_AMBIENT_POINT      2
#define TILEDLIGHT_TYPE_AMBIENT_PROJECTOR  3
#define TILEDLIGHT_TYPE_AMBIENT_AREA       4
#define TILEDLIGHT_TYPE_REGULAR_POINT      5
#define TILEDLIGHT_TYPE_REGULAR_PROJECTOR  6
#define TILEDLIGHT_TYPE_REGULAR_POINTFACE  7
#define TILEDLIGHT_TYPE_REGULAR_AREA       8
#define TILEDLIGHT_TYPE_SUN                9

////////////////////////////////////////////////////////////////////////////

Buffer<uint>                           Fwd_TileLightMask : register(t17);
StructuredBuffer<STiledLightShadeInfo> Fwd_TiledLightsShadeInfo : register(t18);
StructuredBuffer<STiledClipVolumeInfo> Fwd_TiledClipVolumeInfo : register(t19);
TextureCubeArray<float4>               Fwd_SpecCubeArray : register(t20);
TextureCubeArray<float4>               Fwd_DiffuseCubeArray : register(t21);
Texture2DArray<float4>                 Fwd_SpotTexArray : register(t22);
Texture2D<float4>                      Fwd_ShadowPool : register(t23);
Texture2D<float4>                      Fwd_RandomRotations : register(t24);
Texture2D<float4>                      Fwd_EnvironmentBRDF : register(t40);

#if FEATURE_SVO_GI
Texture2D<float4>                      Fwd_GiDiffuseRT : register(t46);
Texture2D<float4>                      Fwd_GiSpecularRT : register(t47);
float4 ForwGiIntegrationMode : PB_SvoParams4;
#endif

SamplerComparisonState SampStateComp : register(s14);

#define SHADOW_SAMPLE_COUNT 16
float4 irreg_kernel_2d[SHADOW_SAMPLE_COUNT/2] : PB_IrregKernel;
float4 ClipVolumeParams : PB_ClipVolumeParams;

#ifndef AFFECTS_EVERYTHING_STENCILREF 
#define AFFECTS_EVERYTHING_STENCILREF	0xFF
#endif

float GetClipVolumeWeightBinary(uint nClipVolumeID, uint nLightStencilID)
{
	const uint nLightStencilID0 = nLightStencilID & 0xFF;
	const uint nLightStencilID1 = nLightStencilID >> 16;
	
	return (nLightStencilID0 == AFFECTS_EVERYTHING_STENCILREF || nClipVolumeID == nLightStencilID0 || nClipVolumeID == nLightStencilID1) ? 1.0f : 0.0f;
}

#if FEATURE_SVO_GI
void ApplyGI(inout float3 specularAcc, inout float3 diffuseAcc, float3 diffuseForwAcc, float2 pixelUV, float3 surfGloss, float3 surfSpecCol,
             Texture2D<float4> TexGiDiffuse, Texture2D<float4> TexGiSpecular, SamplerState samplerTrilinearClamp, const int nIntegrMode)
{
	if(nIntegrMode == 0) // AO only mode
	{
		float4 vSkyLightIrradiance = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc *= lerp(vSkyLightIrradiance.xyz, 1.f, surfGloss * GetLuminance(surfSpecCol));
		diffuseAcc *= vSkyLightIrradiance.xyz; // AO + sun bounces
	}
	else if(nIntegrMode == 1) // GI replaces diffuse of env probes and adjusts specular
	{
		float3 diffuseIrradiance = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc *= lerp(min( 2.f, GetLuminance(diffuseIrradiance) / (GetLuminance(diffuseAcc + diffuseForwAcc) + 0.001)), 1.f, saturate(surfGloss * GetLuminance(surfSpecCol) * ForwGiIntegrationMode.x)) * ForwGiIntegrationMode.z;
		diffuseAcc = diffuseIrradiance;
	}
	else if(nIntegrMode == 2) // Full GI mode
	{
		diffuseAcc = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc = TexGiSpecular.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
	}
}
#endif

int GetNextTileLightIndex(uint lightMask, int startIndex)
{
	uint mask = startIndex < 31 ? ~((1 << (startIndex + 1)) - 1) : 0;
	return firstbitlow(lightMask & mask);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
#if !TILED_DEFERRED_SHADING_TECHNIQUE
////////////////////////////////////////////////////////////////////////////////////////////////////

void TiledForwardShading(in ForwardShadingAttribs attribs, inout float3 diffuseAcc, inout float3 specularAcc, SamplerState ssTrilinearClamp, SamplerComparisonState ssComparison,
                         const bool shadowHighQualityFiltering, const bool applyProbes, const bool applyNonProbes, const bool bSkipSpecularProbes = false, const bool bOpaque = false)
{
	uint2 numTiles = ceil( CV_ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	
	float2 tcProj = attribs.screenUV;
	uint2 tileIdx = uint2( tcProj.x * numTiles.x, tcProj.y * numTiles.y );
	uint bufferIdx = (tileIdx.y * numTiles.x + tileIdx.x) * 8;
	
	float probeWeightSum = 0;
	float3 viewVec = -normalize(attribs.worldPos);
	float specCubeLod = TILED_SHADING_SPECPROBE_MAXMIP - attribs.smoothness * TILED_SHADING_SPECPROBE_MAXMIP;
	float NdotV = saturate(dot(viewVec, attribs.normalSpecProbe));
	float3 envFresnel = GetEnvmapFresnel(attribs.reflectance, attribs.smoothness, NdotV);
#if %_RT_PER_INSTANCE_CB_TEMP
	float2 envBRDF = Fwd_EnvironmentBRDF.SampleLevel(ssTrilinearClamp, float2(NdotV, attribs.smoothness), 0).xy;
	envFresnel = lerp(envBRDF.xxx, envBRDF.yyy, attribs.reflectance);
#endif

	float2 occlusion = float2(1, 1);
	if (bOpaque)
	{
		float aoAmount = Fwd_RandomRotations[attribs.screenUV * CV_ScreenSize.xy].w;
		float occlDiff = saturate(1 - aoAmount * 1.0);
		float occlSpec = saturate(1 - aoAmount * 1.5);
		occlusion.x = occlDiff * occlDiff;
		occlusion.y = DeriveSpecularOcclusion(NdotV, max(occlSpec * occlSpec, 0.3), attribs.smoothness);
	}
	
	int lightIndex = -1;
	uint maskIndex = 0;
	uint curMask = Fwd_TileLightMask[bufferIdx];
	
	[loop]
	for (;;)
	{
		while (maskIndex < 8)
		{
			lightIndex = GetNextTileLightIndex(curMask, lightIndex);
			if (lightIndex >= 0) break;
			else curMask = Fwd_TileLightMask[++maskIndex + bufferIdx];
		}
		
		[branch]
		if (lightIndex < 0 || Fwd_TiledLightsShadeInfo[lightIndex].lightType > TILEDLIGHT_TYPE_AMBIENT_AREA)
			break;
			
		if (applyProbes)
		{
		#if !%_RT_PER_INSTANCE_CB_TEMP
			const float clipVolumeWeight = GetClipVolumeWeightBinary(ClipVolumeParams.x, Fwd_TiledLightsShadeInfo[lightIndex].stencilID);
		#else
			const float clipVolumeWeight = 1;  // TODO
		#endif
			if (Fwd_TiledLightsShadeInfo[lightIndex].lightType == TILEDLIGHT_TYPE_PROBE && probeWeightSum < 1 && clipVolumeWeight > 0)
			{
				STiledLightShadeInfo light = Fwd_TiledLightsShadeInfo[lightIndex];
				float3 position = attribs.worldPos;
				float3 lightVec = (light.posRad.xyz - GetWorldViewPos()) - position;
				
				// Compute attenuation for box
				float3 tmpLightVec;
				tmpLightVec.x = dot( light.projectorMatrix[0].xyz, lightVec );
				tmpLightVec.y = dot( light.projectorMatrix[1].xyz, lightVec );
				tmpLightVec.z = dot( light.projectorMatrix[2].xyz, lightVec );
				
				[branch] if (abs(tmpLightVec.x) < 1 && abs(tmpLightVec.y) < 1 && abs(tmpLightVec.z) < 1)  // Required for correctness and performance
				{
					tmpLightVec = MapCubeToSphere( tmpLightVec );
					float attenuation = GetAttenuation( tmpLightVec, 1, true, light.attenuationParams.y ) * light.attenuationParams.x;
				
					// Diffuse
					float4 diffuseProbe = Fwd_DiffuseCubeArray.SampleLevel( ssTrilinearClamp, float4( attribs.normal, light.resIndex ), 0 );
					diffuseProbe.rgb = DecodeHDRCubemap( diffuseProbe );
					float probeWeight = (1 - probeWeightSum) * attenuation;
					diffuseAcc += diffuseProbe.rgb * light.color.rgb * probeWeight * occlusion.x;
			
					if (!bSkipSpecularProbes)
					{
						// Specular
						float tmpGloss = 0;
						float3 tmpReflVec = reflect(-viewVec, attribs.normalSpecProbe);
						CubemapBoxParallaxCorrection( tmpReflVec, position, (light.posRad.xyz - GetWorldViewPos()), light.shadowMatrix[0].xyz, light.shadowMatrix[1].xyz, tmpGloss );
						float4 specularProbe = Fwd_SpecCubeArray.SampleLevel( ssTrilinearClamp, float4( tmpReflVec, light.resIndex ), specCubeLod );
						specularProbe.rgb = DecodeHDRCubemap( specularProbe ) * envFresnel;
						specularAcc += specularProbe.rgb * light.color.rgb * light.color.a * probeWeight * occlusion.y;
					}	
					
					probeWeightSum += probeWeight;
				}
			}
		}
	}
		
#if FEATURE_SVO_GI
#if !%_RT_PER_INSTANCE_CB_TEMP	
	//if(!pPass.bRefractionMap)
		ApplyGI(specularAcc, diffuseAcc, diffuseAcc, tcProj + .5f / CV_ScreenSize.xy, attribs.smoothness, attribs.reflectance,  // TODO
		        Fwd_GiDiffuseRT, Fwd_GiSpecularRT, ssTrilinearClamp, (int)(ForwGiIntegrationMode.y));
#endif
#endif

	for (;;)
	{
		[branch]
		if (lightIndex < 0)
			break;

		const float3 position = attribs.worldPos;
		const float4 posRad = Fwd_TiledLightsShadeInfo[lightIndex].posRad;
		const float3 lightVec = (posRad.xyz - GetWorldViewPos()) - position;
		
		if (applyNonProbes && Fwd_TiledLightsShadeInfo[lightIndex].lightType > TILEDLIGHT_TYPE_AMBIENT_AREA && length( lightVec ) < posRad.w)
		{
			STiledLightShadeInfo light = Fwd_TiledLightsShadeInfo[lightIndex];
			bool skipShading = false;
			bool shadowMap = false;
			
			ForwardLightParams lightParams;
			lightParams.type = LT_TILED;
			lightParams.lightVec = normalize(lightVec);
			lightParams.illuminance = light.color.rgb;
			
			float attenuation = GetPhysicalLightAttenuation( length( lightVec ), 1.0 / light.posRad.w, light.attenuationParams.x );
			lightParams.illuminance *= attenuation;
			
		#if !%_RT_PER_INSTANCE_CB_TEMP	
			const float clipVolumeWeight = GetClipVolumeWeightBinary(ClipVolumeParams.x, light.stencilID);
		#else
			const float clipVolumeWeight = 1;
		#endif
			[branch] if( clipVolumeWeight == 0.0f)
				skipShading = true;

			if (light.lightType == TILEDLIGHT_TYPE_REGULAR_PROJECTOR)
			{
				if (attenuation > 0)
				{
					float4 projTC = mul( light.projectorMatrix, float4( position + GetWorldViewPos(), 1.0f ) );  
					projTC.xy /= projTC.w;		
						
					if (projTC.w < 0 || min( projTC.x, projTC.y ) < 0 || max( projTC.x, projTC.y ) > 1)  // Avoid back-projection
						skipShading = true;
					else
						lightParams.illuminance *= Fwd_SpotTexArray.SampleLevel( ssTrilinearClamp, float3(projTC.xy, light.resIndex), 0 ).xxx;
						
					if (light.shadowParams.x > 0)
						shadowMap = true;
				}
			}
			else if (light.lightType == TILEDLIGHT_TYPE_REGULAR_POINTFACE)
			{
				float3 dir = abs( lightVec );
				uint cubeFace = dir.x > dir.y ? (dir.x > dir.z ? (lightVec.x < 0 ? 0 : 1) : (lightVec.z < 0 ? 4 : 5)) :
																				(dir.y > dir.z ? (lightVec.y < 0 ? 2 : 3) : (lightVec.z < 0 ? 4 : 5));
				
				if (light.resIndex != cubeFace)
					skipShading = true;
				else
					shadowMap = true;
			}
				
			if (!skipShading)
			{
				float shadowOccl = 1;
				
				if (shadowMap)
				{
					float4 P0 = mul( light.shadowMatrix, float4( position + GetWorldViewPos(), 1 ) );
					P0.xy /= P0.w;
					P0.z -= light.shadowParams.y;
					
					bool bAllowHighQualityShadows = true;
				#if %_RT_PER_INSTANCE_CB_TEMP
					bAllowHighQualityShadows = false;
				#endif
					
					if (bOpaque)
					{
						int3 sampleCoords = int3(attribs.screenUV * CV_ScreenSize.xy, light.shadowMaskIndex);
						shadowOccl = 1 - Fwd_SunShadowMask[sampleCoords];
					}
					else if (shadowHighQualityFiltering && bAllowHighQualityShadows)
					{
						float2 kernelRadius = light.shadowParams.x;
						float2 rotScale = kernelRadius.y * 1000.0f;

						const int nRotationTextureSize = 64;
						int2 sampleCoords = int2(P0.xy * rotScale.xy * nRotationTextureSize) % nRotationTextureSize;
						
						half2 rotSample = Fwd_RandomRotations.Load(int3(sampleCoords, 0)).xy;
						rotSample.xy *= kernelRadius.xy * 1/512.0f;
						float4 rot = float4(rotSample.x, -rotSample.y, rotSample.y, rotSample.x);
						
						shadowOccl = 0;
						for(int s = 0; s < SHADOW_SAMPLE_COUNT / 2; s += 2) // Loop over taps
						{
							half4 sampleDepth;
							{
								// Rotate tap for this pixel location
								float4 rotatedOff0 = rot.xyzw * irreg_kernel_2d[s+0].xxww +	rot.zwxy * irreg_kernel_2d[s+0].yyzz;
								float4 rotatedOff1 = rot.xyzw * irreg_kernel_2d[s+1].xxww +	rot.zwxy * irreg_kernel_2d[s+1].yyzz;

								sampleDepth.x = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff0.xy, P0.z);
								sampleDepth.y = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff0.zw, P0.z);
								sampleDepth.z = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff1.xy, P0.z);
								sampleDepth.w = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff1.zw, P0.z);
							}

							shadowOccl += dot(sampleDepth, 1.0 / SHADOW_SAMPLE_COUNT);
						}
					}
					else
					{
						shadowOccl = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy, P0.z );
					}
				}

				lightParams.illuminance *= shadowOccl;
				
				float3 diffuse, specular;
				Callback_ShadingDirect(attribs, lightParams, diffuse, specular);
				diffuseAcc += diffuse;
				specularAcc += specular;
			}
		}
		
		while (maskIndex < 8)
		{
			lightIndex = GetNextTileLightIndex(curMask, lightIndex);
			if (lightIndex >= 0) break;
			else curMask = Fwd_TileLightMask[++maskIndex + bufferIdx];
		}
	}
}

#endif


////////////////////////////////////////////////////////////////////////////////////////////////////
#if TILED_DEFERRED_SHADING_TECHNIQUE
////////////////////////////////////////////////////////////////////////////////////////////////////

// The benefit of using the depth mask is currently not enough to cover the cost of generating it
//#define USE_DEPTH_MASK

float4 ProjParams;
float4 ScreenSize;
float4 SunDir;
float4 SunColor;
float4 SSDOParams;

SamplerState SampStateTrilinearClamp : register(s0);

RWBuffer<uint> TileTranspLightMaskUAV : register(u0);
RWTexture2D<float4> HDRSceneTargetUAV : register(u1);
RWTexture2D<float4> DiffuseAccUAV : register(u2);

Texture2D<float4> DepthRT: register(t0);
Texture2D<float4> NormalRT : register(t1);
Texture2D<float4> SpecularRT : register(t2);
Texture2D<float4> DiffuseRT : register(t3);
Texture2DArray<float4> ShadowMaskRT : register(t4);
Texture2D<float4> DirectionalOccRT : register(t5);
Texture2D<float4> SSReflectionRT : register(t6);
Texture2D<float4> EnvBRDF : register(t7);
Texture2D<float4> ClipVolumeIndexRT : register(t8);
Texture2D<float4> AOColorBleedRT : register(t9);
Texture2D<float4> GiDiffuseRT : register(t10);
Texture2D<float4> GiSpecularRT : register(t11);
Texture2D<float4> CausticsRT : register(t12);

Buffer<uint>                           TileLightMask : register(t16);
StructuredBuffer<STiledLightCullInfo>  TiledLightsCullInfo : register(t16);
StructuredBuffer<STiledLightShadeInfo> TiledLightsShadeInfo : register(t17);
StructuredBuffer<STiledClipVolumeInfo> TiledClipVolumeInfo : register(t18);
TextureCubeArray<float4>               SpecCubeArray : register(t19);
TextureCubeArray<float4>               DiffuseCubeArray : register(t20);
Texture2DArray<float4>                 SpotTexArray : register(t21);


groupshared uint sTileLightCount;
groupshared uint sTileLightIndices[TILED_SHADING_MAX_NUM_LIGHTS];
groupshared uint sTileMinZ;
groupshared uint sTileMaxZ;
groupshared uint sTileDepthMask;
groupshared uint sTileWithinProjection;
groupshared uint sTileLightMask[8];
groupshared uint sTileLightMaskCounts[8];

////////////////////////////////////////////////////////////////////////////////////////////////////

[numthreads(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y, 1)]
void TiledDeferredShadingCS( uint3 GroupID : SV_GroupID,
                             uint3 GroupThreadID : SV_GroupThreadID )
{
	const uint groupThreadIdx = GroupThreadID.y * TILED_SHADING_TILE_SIZE_X + GroupThreadID.x;
	const uint2 pixelCoord = GroupID.xy * uint2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) + GroupThreadID.xy;
	
	// Barycentric interpolation for reconstructing position
	float2 pixelUV = float2( (pixelCoord.x + 0.5) * ScreenSize.z, (pixelCoord.y + 0.5) * ScreenSize.w );
	float2 linearUV = MapRasterToViewport(pixelUV);
	bool bWithinProjection = all(linearUV.xy > 0) && all(linearUV.xy < 1);

	// Find out if any threads in the tile are within the projection
	// The shared flag is set to 1 after a barrier, merged with other barrier code below
	if(groupThreadIdx == 0)
		sTileWithinProjection = 0;

#if !%_RT_SAMPLE1	
	// Initialize shared memory
	if (groupThreadIdx == 0)
	{
		sTileLightCount = 0;
		sTileMinZ = 0x7F7FFFFF;  // Max float
		sTileMaxZ = 0;
		sTileDepthMask = 0;
	}
	
	sTileLightIndices[groupThreadIdx] = TILED_SHADING_MAX_NUM_LIGHTS;
	
	// Fudge maxZ to prevent division by 0 when minZ is equal maxZ
	// it also assures the depth-mask bins of [0,32) instead of [0,32]
	float linearZ = DepthRT[pixelCoord].r;
	float minZSample = linearZ;
	float maxZSample = linearZ + 0.0001;

	GroupMemoryBarrierWithGroupSync();
	
	// Find tile z bounds
	InterlockedMin( sTileMinZ, asuint( minZSample ) );
	InterlockedMax( sTileMaxZ, asuint( maxZSample ) );

	if(bWithinProjection)
		sTileWithinProjection = 1;

	GroupMemoryBarrierWithGroupSync();
	
	if(sTileWithinProjection == 0)
		return;
	
	float tileMinZ = asfloat( sTileMinZ );
	float tileMaxZ = asfloat( sTileMaxZ );
	bool emptyTile = (tileMinZ == 1.0);
	bool isSkyPixel = (linearZ == 1.0);
	
	// Scale and bias for frustum to fit grid cells
	float2 numTiles = ceil( ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	float2 tileScale = numTiles / 2.0;
	float2 tileBias = tileScale - float2( GroupID.xy );
	
	// Extract projection matrix columns (including PostAA bias)
	float4 col1 = float4( ProjParams.x * tileScale.x, 0.0f, ProjParams.z + tileBias.x, 0.0f );
	float4 col2 = float4( 0.0f, -ProjParams.y * tileScale.y, ProjParams.w + tileBias.y, 0.0f );
	float4 col4 = float4( 0.0f, 0.0f, 1.0f, 0.0f );

	float4 frustumPlanes[4];
	frustumPlanes[0] = normalize( col4 - col1 );
	frustumPlanes[1] = normalize( col4 + col1 );
	frustumPlanes[2] = normalize( col4 - col2 );
	frustumPlanes[3] = normalize( col4 + col2 );
	
#ifdef USE_DEPTH_MASK
	// Create depth coverage mask for tile
	// Fudge guarantees (32  * z) / (z + 0.0001) < 32
	float tileDepthExtent = rcp( tileMaxZ - tileMinZ );
	uint cellIndex = ((linearZ - tileMinZ) * tileDepthExtent) * 32;
	GroupMemoryBarrierWithGroupSync();
	InterlockedOr( sTileDepthMask, 1UL << cellIndex );
	GroupMemoryBarrierWithGroupSync();
#endif
	
	// ==============================================================================================
	// Light culling
	// ==============================================================================================
	
	uint tileIdx = GroupID.y * numTiles.x + GroupID.x;
	
	// Cull against frustum planes
	[unroll]
	for (uint lightIdx = groupThreadIdx; lightIdx < TILED_SHADING_MAX_NUM_LIGHTS; lightIdx += TILED_THREAD_GROUP_SIZE)
	{
		uint volumeType = TiledLightsCullInfo[lightIdx].volumeType;
		
		if (volumeType == 0)
			break;
		
		const float lightMinZ = TiledLightsCullInfo[lightIdx].depthBounds.x;
		const float lightMaxZ = TiledLightsCullInfo[lightIdx].depthBounds.y;

		// Test far plane
		// The tileMaxZ value is a bit larger than the real maximum Z because of the fudge: use < instead of <=
		bool inFrustum = ( lightMinZ < tileMaxZ );
		
		if (inFrustum)
		{
			float4 lightPosRad = TiledLightsCullInfo[lightIdx].posRad;
			float4 lightDists;
			
			[unroll]
			for (uint j = 0; j < 4; ++j)
			{
				lightDists[j] = dot( frustumPlanes[j], float4( lightPosRad.xyz, 1 ) );
			}
			
			if (volumeType == TILEDLIGHT_VOLUME_SPHERE)
			{
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// Simple sphere culling
					inFrustum = inFrustum && (lightDists[j] >= -lightPosRad.w);
				}
			}
			else if (volumeType == TILEDLIGHT_VOLUME_CONE)
			{
				const float4 spotParams = TiledLightsCullInfo[lightIdx].volumeParams0;
				
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// Cone culling
					float3 v = spotParams.xyz;
					float3 Q = lightPosRad.xyz - v * lightPosRad.w;
					Q += spotParams.w * (frustumPlanes[j].xyz - v * dot( v, frustumPlanes[j].xyz ));
					float dBase = dot( frustumPlanes[j], float4( Q, 1.0f ) );
					inFrustum = inFrustum && (((lightDists[j] > 0) || (dBase > 0)) && (lightDists[j] >= -lightPosRad.w));  // Including sphere test for more accurate culling
				}
			}
			else if (volumeType == TILEDLIGHT_VOLUME_OBB)
			{
				float4 u0 = TiledLightsCullInfo[lightIdx].volumeParams0;
				float4 u1 = TiledLightsCullInfo[lightIdx].volumeParams1;
				float4 u2 = TiledLightsCullInfo[lightIdx].volumeParams2;
				
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// OBB culling
					float r = dot( float3( u0.w, u1.w, u2.w ), float3( abs(dot( frustumPlanes[j].xyz, u0.xyz )), abs(dot( frustumPlanes[j].xyz, u1.xyz )), abs(dot( frustumPlanes[j].xyz, u2.xyz )) ) ) ;
					inFrustum = inFrustum && (-lightDists[j] <= r);// detect OBB intersects or is inside the plane.
				}
			}
		
			if (inFrustum)
			{
				// Test near plane
				[branch]
				if ((lightMaxZ >= tileMinZ) && !emptyTile)
				{

				#ifdef USE_DEPTH_MASK
					// saturate() allows [0,1], thus the shift can become 32 if lightMinZ equals exactly lightMaxZ
					// The shift is masked (32 & 0x1F) and does nothing in case 32, except registering the light in all bits (worst case)
					uint lightShiftMin = saturate( (lightMinZ - tileMinZ) * tileDepthExtent ) * 32;
					uint lightShiftMax = saturate( (tileMaxZ - lightMaxZ) * tileDepthExtent ) * 32;
					uint lightMask = (0xFFFFFFFFUL << lightShiftMin) & (0xFFFFFFFFUL >> lightShiftMax);

					if ((lightMask & sTileDepthMask) != 0)
				#endif
					{
						uint listIndex;
						InterlockedAdd( sTileLightCount, 1, listIndex );
						sTileLightIndices[listIndex] = lightIdx;
					}
				}

				[branch]
				if (volumeType != TILEDLIGHT_VOLUME_SUN)
				{
					uint bufferBaseIdx = tileIdx * 8;
					uint maskIndex = lightIdx / 32;
					InterlockedOr(TileTranspLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightIdx & 31));
				}
			}
		}
	}
	
	GroupMemoryBarrierWithGroupSync();
	
#if !DURANGO && !ORBIS
	// Apply bitonic sort to the first 64 lights; not required on AMD/Durango when no more than 64 threads are used
	[unroll]
	for (uint k = 2; k <= 64; k = 2 * k)
	{
		[unroll]
		for (uint j = k / 2; j > 0 ; j /= 2)
		{
				uint i = groupThreadIdx;
				uint result1 = ((sTileLightIndices[i & ~j] <= sTileLightIndices[i | j]) == (bool)(k & i)) ? sTileLightIndices[i ^ j] : sTileLightIndices[i];
				GroupMemoryBarrierWithGroupSync();
				sTileLightIndices[i] = result1;
				GroupMemoryBarrierWithGroupSync();
		}
	}
#endif
	
#else
	
	float2 numTiles = ceil( ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	uint tileIdx = GroupID.y * numTiles.x + GroupID.x;
	uint bufferBaseIdx = tileIdx * 8;
	
	if (groupThreadIdx < 8)
	{
		if (groupThreadIdx == 0)
			sTileLightCount = 0;
		
		uint lightMask = TileLightMask[bufferBaseIdx + groupThreadIdx];
		sTileLightMask[groupThreadIdx] = lightMask;
		sTileLightMaskCounts[groupThreadIdx] = countbits(lightMask);
		InterlockedAdd(sTileLightCount, sTileLightMaskCounts[groupThreadIdx]);
	}
	GroupMemoryBarrierWithGroupSync();
	
	if (groupThreadIdx < 8)
	{
		uint offset = 0;
		for (uint i = 0; i < groupThreadIdx; i++)
			offset += sTileLightMaskCounts[i];
		
		uint lightCount = 0;
		int lightIndex = GetNextTileLightIndex(sTileLightMask[groupThreadIdx], -1);
		while (lightIndex >= 0)
		{
			sTileLightIndices[offset + lightCount++] = groupThreadIdx * 32 + lightIndex;
			lightIndex = GetNextTileLightIndex(sTileLightMask[groupThreadIdx], lightIndex);
		}
	}
	
	if(bWithinProjection)
		sTileWithinProjection = 1;

	GroupMemoryBarrierWithGroupSync();
	
	if(sTileWithinProjection == 0)
		return;

	bool emptyTile = sTileLightCount == 0;
	float linearZ = DepthRT[pixelCoord].r;
#endif
	
	// ==============================================================================================
	// Overdraw visualization
	// ==============================================================================================
	
#if %_RT_SAMPLE2
	{
		float x = (float)sTileLightCount / 16.0;
		float w0 = x * 2;
		float w1 = x * 2 - 1;
		float3 finalCol = x < 0.5 ? lerp(float3(0, 0, 0.25), float3(1, 0, 0), float3(w0*w0, 0, w0))
		                          : lerp(float3(1, 0, 0.00), float3(1, 1, 0), float3(w1*w1, w1*w1, 0));
		
		if (x == 0) finalCol = float3(0, 0, 0);
		else if (x > 1) finalCol = float3(1, 1, 1);
		
		HDRSceneTargetUAV[pixelCoord] = float4(finalCol, 1);
		return;
	}
#endif
	
	// ==============================================================================================
	// Shading for tiles
	// ==============================================================================================
	
#if %_RT_SAMPLE0
	MaterialAttribsCommon attribs = DecodeGBuffer( NormalRT[pixelCoord], DiffuseRT[pixelCoord], SpecularRT[pixelCoord] );
	float3 surfNormal = attribs.NormalWorld;
	bool surfIsTranslucent = attribs.LightingModel == LIGHTINGMODEL_TRANSMITTANCE;
	float3 surfTransmittanceColor = attribs.Transmittance;
	float3 surfSpecCol = attribs.Reflectance;
	float surfGloss = attribs.Smoothness;

	float3 position = ReconstructWorldPos(pixelCoord, linearZ, true);
	
	float3 viewVec = normalize( -position );
	
	float probeWeightSum = 0;
	float3 diffuseAcc = 0;
	float3 specularAcc = 0;
	
	int lightType;
	int curLight = 0;
	int lightIndex = sTileLightCount > 0 ? sTileLightIndices[0] : 0;
	
	const uint 	clipVolumeStencilID = ClipVolumeIndexRT[pixelCoord].x * 255.0f;
	const uint  clipVolumeData = TiledClipVolumeInfo[clipVolumeStencilID & (MAX_CLIPVOLUMES-1)].data;
	const float clipVolumeBlendFactor = ClipVolumeIndexRT[pixelCoord].y;
	
	// ==============================================================================================
	// Environment probes
	// ==============================================================================================
	{
		float3 reflVec = normalize( reflect( position, surfNormal ) );
		float specCubeLod = TILED_SHADING_SPECPROBE_MAXMIP - surfGloss * TILED_SHADING_SPECPROBE_MAXMIP;
		
		while (curLight < sTileLightCount && (lightType = TiledLightsShadeInfo[lightIndex].lightType) == TILEDLIGHT_TYPE_PROBE)
		{
			const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID);
			[branch] if (probeWeightSum < 1.0 && clipVolumeBlendWeight > 0)
			{
				STiledLightShadeInfo light = TiledLightsShadeInfo[lightIndex];
				float3 lightVec = (light.posRad.xyz - GetWorldViewPos()) - position.xyz;
				
				// Compute attenuation for box
				float3 tmpLightVec;
				tmpLightVec.x = dot( light.projectorMatrix[0].xyz, lightVec );
				tmpLightVec.y = dot( light.projectorMatrix[1].xyz, lightVec );
				tmpLightVec.z = dot( light.projectorMatrix[2].xyz, lightVec );
				
				[branch] if (max( max( abs(tmpLightVec.x), abs(tmpLightVec.y) ), abs(tmpLightVec.z) ) < 1)  // Required for correctness and performance
				{
					tmpLightVec = MapCubeToSphere( tmpLightVec );
					float attenuation = GetAttenuation( tmpLightVec, 1, true, light.attenuationParams.y ) * light.attenuationParams.x;
				
					// Diffuse
					float4 diffuseProbe = DiffuseCubeArray.SampleLevel( SampStateTrilinearClamp, float4( surfNormal, light.resIndex ), 0 );
					diffuseProbe.rgb = DecodeHDRCubemap( diffuseProbe );
					[branch] if (surfIsTranslucent)
					{
						float4 diffuseProbe2 = DiffuseCubeArray.SampleLevel( SampStateTrilinearClamp, float4( -surfNormal, light.resIndex ), 0 );
						diffuseProbe.rgb += DecodeHDRCubemap( diffuseProbe2 ) * surfTransmittanceColor;
					}
					float probeWeight = (1 - probeWeightSum) * attenuation * clipVolumeBlendWeight;
					diffuseAcc += diffuseProbe.rgb * light.color.rgb * probeWeight;
			
					// Specular
					float tmpGloss = 0;
					float3 tmpReflVec = reflVec;
					CubemapBoxParallaxCorrection( tmpReflVec, position, light.posRad.xyz - GetWorldViewPos(), light.shadowMatrix[0].xyz, light.shadowMatrix[1].xyz, tmpGloss );
					float4 specularProbe = SpecCubeArray.SampleLevel( SampStateTrilinearClamp, float4( tmpReflVec, light.resIndex ), specCubeLod );
					specularProbe.rgb = DecodeHDRCubemap( specularProbe );
					specularAcc += specularProbe.rgb * light.color.rgb * light.color.a * probeWeight;
					
					probeWeightSum += probeWeight;
				}
			}
			
			++curLight;
			lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
		}

#if FEATURE_SVO_GI
		int nIntegrMode = -1;
		#if %_RT_CUBEMAP0 && !%_RT_DECAL_TEXGEN_2D  // AO only mode
		nIntegrMode = 0;
		#elif !%_RT_CUBEMAP0 && %_RT_DECAL_TEXGEN_2D  // GI replaces diffuse of env probes and adjusts specular
		nIntegrMode = 1;
		#elif %_RT_CUBEMAP0 && %_RT_DECAL_TEXGEN_2D  // Full GI mode
		nIntegrMode = 2;
		#endif

		ApplyGI(specularAcc, diffuseAcc, 0, pixelUV + .5f / ScreenSize.xy, surfGloss, surfSpecCol,
		        GiDiffuseRT, GiSpecularRT, SampStateTrilinearClamp, nIntegrMode);
#endif
	}
		
	float4 occlusionData = DirectionalOccRT[pixelCoord];
	occlusionData.xyz = occlusionData.xyz * 2 - 1;
		
	{	
		// Ambient occlusion
		float occlDiff = saturate( 1 - occlusionData.a * SSDOParams.y );
		occlDiff *= occlDiff;
		// Apply simple color bleeding approximation to AO
		float3 bleedColor = AOColorBleedRT.SampleLevel( SampStateTrilinearClamp, pixelUV, 0 );
		diffuseAcc *= pow( occlDiff, 1 - min( bleedColor * bleedColor * bleedColor * 3, 0.7 ) );
		
		// Specular occlusion
		float NdotV = dot( -normalize( position ), surfNormal );
		float ao = saturate( 1 - occlusionData.a * SSDOParams.z );
		float occlSpec = DeriveSpecularOcclusion( NdotV, max(ao * ao, 0.3), surfGloss );
		specularAcc *= occlSpec;
	}
		
	// ==============================================================================================
	// Ambient lights
	// ==============================================================================================
	while (curLight < sTileLightCount && (lightType = TiledLightsShadeInfo[lightIndex].lightType) <= TILEDLIGHT_TYPE_AMBIENT_AREA)
	{
		STiledLightShadeInfo light = TiledLightsShadeInfo[lightIndex];
		const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, light.stencilID);
		bool skipShading = clipVolumeBlendWeight == 0.0;
		
		if (!skipShading)
		{
			float3 lightVec = (light.posRad.xyz - GetWorldViewPos()) - position.xyz;
			
			float filter = 1;
			float attenuation;
			float NdotL;
			float PdotL = 1;
			
			if (lightType == TILEDLIGHT_TYPE_AMBIENT_AREA)
			{
				lightVec = ComputeNearestLightOnRectangle(position.xyz, lightVec, light.projectorMatrix);

				attenuation = GetAttenuation( lightVec, 1.0 / light.posRad.w );
				
				lightVec = normalize( lightVec );
				PdotL = dot( -lightVec, light.projectorMatrix[0].xyz );

				attenuation *= GetSpotAttenuation(PdotL, light.projectorMatrix[3].w, light.posRad.w); // spot falloff for area light
				attenuation *= attenuation;
				
				NdotL = saturate( dot( surfNormal, lightVec ) ) * saturate( PdotL );
			}
			else
			{
				[branch] if (light.attenuationParams.x > 0)
					attenuation = GetPhysicalLightAttenuation( length( lightVec ), 1.0 / light.posRad.w, light.attenuationParams.x );
				else
					attenuation = GetAttenuation( lightVec, 1.0 / light.posRad.w );
				
				lightVec = normalize( lightVec );
				NdotL = saturate( dot( surfNormal, lightVec ) );
				
				if (lightType == TILEDLIGHT_TYPE_AMBIENT_PROJECTOR)
				{
					filter = 0;
					[branch] if (attenuation > 0)
					{
						float4 vProjTC = mul( light.projectorMatrix, float4( position + GetWorldViewPos(), 1 ) );
						vProjTC.xy /= vProjTC.w;
						
						if (vProjTC.w > 0 && max( abs(vProjTC.x * 2 - 1), abs(vProjTC.y * 2 - 1) ) < 1)  // Avoid back-projection
							filter = SpotTexArray.SampleLevel( SampStateTrilinearClamp, float3( vProjTC.xy, light.resIndex ), 0 ).x;
					}
				}
				else
				{
					attenuation *= attenuation;
				}
			}
			
			// Darkening ambient lights don't use any directionality
			float lightOccl = 0.3 + 0.7 * (1.0 - saturate( dot( lightVec, occlusionData.xyz ) * SSDOParams.x ));
			float3 dirFactor = light.color.xyz > 1 ? float3( NdotL, NdotL, NdotL ) * lightOccl : saturate( float3( PdotL, PdotL, PdotL ) );
			
			attenuation *= clipVolumeBlendWeight;
			float3 lightTerm = lerp( float3( 1, 1, 1 ), light.color.xyz, attenuation * filter * dirFactor );
			diffuseAcc *= lightTerm;
			specularAcc *= lightTerm;
		}
		
		++curLight;
		lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
	}
	
	// Apply Screenspace Reflections
#if %_RT_SAMPLE3
	float4 ssRefl = SSReflectionRT.SampleLevel( SampStateTrilinearClamp, pixelUV, 0 );
	specularAcc = lerp( specularAcc, ssRefl.xyz, ssRefl.w );
#endif

	// Apply Fresnel
	float2 envBRDF = EnvBRDF.SampleLevel( SampStateTrilinearClamp, float2( dot( -normalize( position ), surfNormal ), surfGloss ), 0 ).xy;
	float3 envFresnel = lerp( envBRDF.xxx, envBRDF.yyy, surfSpecCol );
	specularAcc *= envFresnel;
	
	// Apply water caustics
	float3 caustics = CausticsRT.SampleLevel( SampStateTrilinearClamp, pixelUV, 0 ).rgb;
	diffuseAcc += caustics;
		
	// ==============================================================================================
	// Regular lights
	// ==============================================================================================

	while (curLight < sTileLightCount)
	{
		STiledLightShadeInfo light = TiledLightsShadeInfo[lightIndex];
		lightType = light.lightType;
		
		float3 lightVec;
		float3 lightVecAreaSpec;
		float attenuation;
		float PdotL = 1;
		
		[branch] if (lightType == TILEDLIGHT_TYPE_SUN)
		{
			lightVec = SunDir.xyz;
			lightVecAreaSpec = SunDir.xyz * SunDir.w;
			attenuation = (TiledClipVolumeInfo[clipVolumeStencilID].data & CLIPVOLUME_AFFECTED_BY_SUN) ? 1.0 : 0.0;
		}
	#if %_RT_SAMPLE5
		else if (lightType == TILEDLIGHT_TYPE_REGULAR_AREA)
		{
			const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight( clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID );
			lightVec = (light.posRad.xyz - GetWorldViewPos()) - position.xyz;
			lightVecAreaSpec = lightVec;
			lightVec = ComputeNearestLightOnRectangle(position.xyz, lightVec, light.projectorMatrix);
			attenuation = GetPhysicalLightAttenuation( length( lightVec ), 1.0 / light.posRad.w, light.attenuationParams.x ) * clipVolumeBlendWeight;
			lightVec = normalize( lightVec );
			PdotL = dot( -lightVec.xyz, light.projectorMatrix[0].xyz );
			attenuation *= GetSpotAttenuation( PdotL, light.projectorMatrix[3].w, light.posRad.w ) * step( 0, PdotL );
		}
	#endif
		else
		{
			const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID);
			lightVec = (light.posRad.xyz - GetWorldViewPos()) - position.xyz;
			lightVecAreaSpec = lightVec;
			attenuation = GetPhysicalLightAttenuation( length( lightVec ), 1.0 / light.posRad.w, light.attenuationParams.x ) * clipVolumeBlendWeight;

			lightVec = normalize( lightVec );
		}
		
		float NdotL = saturate( dot( surfNormal, lightVec ) ) * saturate( PdotL );
		
		[branch] if (attenuation > 0 && (NdotL > 0 || surfIsTranslucent)) 
		{
			float lightTerm = 1;
			bool shadowMap = light.shadowParams.x > 0;
			bool skipShading = false;
			
			[branch] if (lightType != TILEDLIGHT_TYPE_SUN)
			{
				if (lightType == TILEDLIGHT_TYPE_REGULAR_PROJECTOR)
				{
					float4 vProjTC = mul(light.projectorMatrix, float4(position + GetWorldViewPos(), 1));
					vProjTC.xy /= vProjTC.w;
					
					[branch] if (vProjTC.w < 0 || max( abs(vProjTC.x * 2 - 1), abs(vProjTC.y * 2 - 1) ) > 1)  // Avoid back-projection
						skipShading = true;
					else
						lightTerm = SpotTexArray.SampleLevel( SampStateTrilinearClamp, float3( vProjTC.xy, light.resIndex ), 0 ).r;
				}
				else if (lightType == TILEDLIGHT_TYPE_REGULAR_POINTFACE)
				{
					float3 dir = abs( lightVec );
					uint cubeFace = dir.x > dir.y ? (dir.x > dir.z ? (lightVec.x < 0 ? 0 : 1) : (lightVec.z < 0 ? 4 : 5)) :
																					(dir.y > dir.z ? (lightVec.y < 0 ? 2 : 3) : (lightVec.z < 0 ? 4 : 5));
					
					if (light.resIndex != cubeFace)
						skipShading = true;
				}
			}
			
			if (!skipShading)
			{
				float shadowTerm = 1.0;
				
				[branch] if (shadowMap)
				{
					int3 sampleCoords = int3(pixelCoord, light.shadowMaskIndex);
					shadowTerm = 1 - ShadowMaskRT[sampleCoords];
				}
				
				[branch] if (shadowTerm > 0)
				{
					float lightOccl = 1.0 - saturate( dot( lightVec, occlusionData.xyz ) * SSDOParams.x );
					lightOccl *= lightOccl;
					lightTerm *= attenuation * shadowTerm * lightOccl;
					
					float diffuseTerm = DiffuseBRDF( surfNormal, viewVec, lightVec, surfGloss, NdotL );
					float3 diffuseTranslucency = ThinTranslucencyBRDF( surfNormal, lightVec, surfTransmittanceColor );
					diffuseAcc += lightTerm * light.color.rgb * (surfIsTranslucent ? diffuseTranslucency : diffuseTerm.xxx);
					
				#if %_RT_SAMPLE5
					if (lightType != TILEDLIGHT_TYPE_REGULAR_AREA)
						light.projectorMatrix[3].y = light.attenuationParams.y;
					float3 specTerm = AreaLightGGX( surfNormal, viewVec, lightVecAreaSpec, surfGloss, surfSpecCol, light.projectorMatrix, lightType == TILEDLIGHT_TYPE_REGULAR_AREA ? AREA_LIGHT_RECTANGLE : AREA_LIGHT_SPHERE );
				#else
					float3 specTerm = SpecularBRDF( surfNormal, viewVec, lightVec, surfGloss, surfSpecCol );
				#endif
					specularAcc += lightTerm * light.color.a * specTerm * NdotL * light.color.rgb;
				}
			}
		}
		
		++curLight;
		lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
	}
	
	// Apply albedo
	float4 albedoSSS = DecodeGBufferAlbedoAndScattering( DiffuseRT[pixelCoord] );
	float scatteringIndex = albedoSSS.w;
	float3 surfAlbedo = albedoSSS.rgb;
	surfAlbedo *= saturate( 1 - GetLuminance( surfSpecCol ) );  // Simple energy conservation between specular and diffuse
	
	float3 finalCol = diffuseAcc * surfAlbedo + specularAcc;
	
	// Subsurface Scattering
#if %_RT_SAMPLE4	
	[branch] if (scatteringIndex > 0)
	{
		finalCol = specularAcc;
		diffuseAcc *= floor( scatteringIndex ) != SSS_PROFILE_SKIN ? sqrt( surfAlbedo ) : 1;
	}
	else
	{
		diffuseAcc = 0;
	}
	
	DiffuseAccUAV[pixelCoord] = float4( diffuseAcc, 0 );
#endif

	HDRSceneTargetUAV[pixelCoord] = float4( finalCol, 0 );
#endif
}


technique TiledDeferredShading
{
  pass p0
  {
    ComputeShader = TiledDeferredShadingCS() TiledShadingCS;
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

RWBuffer<uint> VolumeOpaqueLightMaskUAV : register(u0);
RWBuffer<uint> VolumeTranspLightMaskUAV : register(u1);
Buffer<float4> VolumeVertexData         : register(t0);
StructuredBuffer<STiledLightVolumeInfo>   TiledLightsVolumeInfo : register(t1);

cbuffer CBVolumeLightListGen : register(b0)
{
	struct
	{
		float4x4 matViewProj;
		uint     lightIndexOffset;
		uint     numVertices;
		float4   screenScale;
		float4   viewerPos;
		float4   worldBasisX;
		float4   worldBasisY;
		float4   worldBasisZ;
	} cbVolumeLightListGen;
};

struct vtxOutVolumeLightListGen
{
	float4                WPos        : SV_Position;
	nointerpolation uint  lightIndex  : TEXCOORD0;
};

vtxOutVolumeLightListGen VolumeLightListGenVS(uint VertexID : SV_VertexID)
{
	vtxOutVolumeLightListGen OUT = (vtxOutVolumeLightListGen)0; 
	
	const uint numVertices = cbVolumeLightListGen.numVertices;
	const uint vertexIndex = VertexID % numVertices;
	const uint lightIndex = VertexID / numVertices + cbVolumeLightListGen.lightIndexOffset;
	
	float4 pos = VolumeVertexData[vertexIndex];
	pos = mul(pos, TiledLightsVolumeInfo[lightIndex].worldMat);
	pos = mul(pos, cbVolumeLightListGen.matViewProj);
	
	OUT.WPos = pos;
	OUT.lightIndex = lightIndex;

	return OUT;
}

[earlydepthstencil]
void VolumeLightListGenPS(vtxOutVolumeLightListGen IN, bool bIsFrontFace : SV_IsFrontFace)
{
	const uint lightIndex = IN.lightIndex;
	const uint2 pixelPos = IN.WPos.xy;
	
	float2 depthMaxMin = DepthTex.Load(int3(pixelPos.xy, 0)).xy;
	float3 positionMax = CalcHomogeneousPos(1, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
	float3 positionMin = CalcHomogeneousPos(0, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		
	STiledLightVolumeInfo volume = TiledLightsVolumeInfo[lightIndex];
	uint volumeType = volume.volumeTypeInfo.x;
	uint lightId = volume.volumeTypeInfo.w;
	
	uint2 numTiles = (uint2)cbVolumeLightListGen.screenScale.xy;
	uint tileIdx = pixelPos.y * numTiles.x + pixelPos.x;
	uint bufferBaseIdx = tileIdx * 8;
	
	bool bInVolume = (volumeType == TILEDLIGHT_VOLUME_SUN) ? true : false;
	bool bInTranspVolume = bInVolume;
	
	if (volumeType == TILEDLIGHT_VOLUME_OBB)
	{
		// Transform into OBB space
		float3 volumePos = float3(volume.volumeParams0.w, volume.volumeParams1.w, volume.volumeParams2.w) - cbVolumeLightListGen.viewerPos;
		float3 posMinLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMin.xyz);
		float3 posMaxLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMax.xyz);
		
		float3 rayOrig = posMinLS;
		float3 rayDir = normalize(posMaxLS - posMinLS);
			
		// Intersect ray with AABB
		float3 rcpDir = rcp(rayDir);
		float3 tneg = (-volume.volumeParams3.xyz - rayOrig) * rcpDir;
		float3 tpos = ( volume.volumeParams3.xyz - rayOrig) * rcpDir;
		float3 tmin = min(tneg, tpos);
		float3 tmax = max(tneg, tpos);
		float t0 = max(max(tmin.x, tmin.y), tmin.z);
		float t1 = min(min(tmax.x, tmax.y), tmax.z);
		if (t0 <= t1)
		{
			positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			positionMax = CalcHomogeneousPos(depthMaxMin.x, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			posMinLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMin.xyz);
			posMaxLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMax.xyz);
			
			if (t0 <= length(posMaxLS - rayOrig))
			{
				bInTranspVolume = true;
				if (t1 >= length(posMinLS - rayOrig))
					bInVolume = true;
			}
		}
	}
	else if (volumeType == TILEDLIGHT_VOLUME_CONE)
	{
		positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		positionMax = CalcHomogeneousPos(depthMaxMin.x, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		
		float3 forwardVec = volume.volumeParams1.xyz;
		float3 upVector = abs(forwardVec.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
		float3 tangentX = normalize(cross(upVector, forwardVec));
		float3 tangentY = cross(forwardVec, tangentX);
		
		// Compute projector frustum's left, right, top and bottom planes
		float cosFOV = volume.volumeTypeInfo.z;
		float sinFOV = volume.volumeTypeInfo.y;
		float3 N0 =  tangentX * cosFOV - forwardVec * sinFOV;
		float3 N1 = -tangentX * cosFOV - forwardVec * sinFOV;
		float3 N2 =  tangentY * cosFOV - forwardVec * sinFOV;
		float3 N3 = -tangentY * cosFOV - forwardVec * sinFOV;
		
		// Check near plane
		const float3 P0 = volume.volumeParams0.xyz - cbVolumeLightListGen.viewerPos;
		bInVolume = dot(-volume.volumeParams1.xyz, positionMin - P0) >= 0 || dot(-volume.volumeParams1.xyz, positionMax - P0) >= 0;
		
		// Check if min and max position are both on same side of planes
		if (dot(N0, positionMin - P0) < 0 && dot(N0, positionMax - P0) < 0) bInVolume = false;
		if (dot(N1, positionMin - P0) < 0 && dot(N1, positionMax - P0) < 0) bInVolume = false;
		if (dot(N2, positionMin - P0) < 0 && dot(N2, positionMax - P0) < 0) bInVolume = false;
		if (dot(N3, positionMin - P0) < 0 && dot(N3, positionMax - P0) < 0) bInVolume = false;
		
		// Far plane
		float3 P1 = P0 - volume.volumeParams1.xyz * volume.volumeParams0.w;
		if (dot(volume.volumeParams1.xyz, positionMin - P1) < 0 && dot(volume.volumeParams1.xyz, positionMax - P1) < 0) bInVolume = false;
		
		// TODO: Implement culling for transparent case - this is very inefficient now
		bInTranspVolume = true;
	}
	else if (volumeType == TILEDLIGHT_VOLUME_SPHERE)
	{
		float3 rayOrig = positionMin;
		float3 rayDir = normalize(positionMax - positionMin);
		
		// Intersect ray with sphere
		float3 volumePos = volume.volumeParams0.xyz - cbVolumeLightListGen.viewerPos;
		float3 v = volumePos - rayOrig;
		float b = dot(v, rayDir);
		float radius2 = volume.volumeParams0.w * volume.volumeParams0.w;
		float d2 = radius2 - (dot(v, v) - b * b);
		if (d2 >= 0)
		{
			float t0 = b - sqrt(d2);
			float t1 = b + sqrt(d2);
			
			positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			
			bInTranspVolume = true;
			if (t1 >= length(positionMin - rayOrig))
				bInVolume = true;
		}
	}
	
	uint maskIndex = lightId / 32;
	[branch] if (bInTranspVolume)
		InterlockedOr(VolumeTranspLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightId & 31));
	[branch] if (bInVolume)
		InterlockedOr(VolumeOpaqueLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightId & 31));
}

technique VolumeLightListGen
{
  pass p0
  {
    VertexShader = VolumeLightListGenVS();
    PixelShader  = VolumeLightListGenPS();
  }
}

#endif
