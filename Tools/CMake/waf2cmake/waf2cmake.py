#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function, absolute_import, unicode_literals

import sys, os, imp, json, time, re, pprint, subprocess, argparse, stat, shutil

sys.path.insert(0, os.path.abspath('Code/Tools/waf-1.7.13'))
from waflib import Context, ConfigSet, Logs

# Python 2/3 compatibility.
if sys.version_info[0] == 3:
	basestring = str
else:
	input = raw_input

def ensure_list(v):
	if isinstance(v, basestring):
		return [v,]
	return list(v)

def generate_platform_condition(platforms):
	l = []
	mapping = {
		'durango_file_list': 'DURANGO',
		'orbis_file_list' : 'ORBIS',
		'win_file_list': 'WIN32',
		'android_file_list': 'ANDROID',
		'darwin_file_list': 'APPLE',
		'linux_file_list': 'LINUX'
	}
	if any(p.endswith('/file_list') for p in platforms):
		return 'ALL'
	for p in platforms:
		for m in mapping:
			if p.endswith(m) and mapping[m] not in l:
				l.append(mapping[m])
	return ' '.join(sorted(l))

def read_file_lists(path):
	file_lists = {}
	platform_lists = {}
	project_lists = {}
	for c in bld.collected:
		if c[0] == path:
			for k in c[3]:
				if 'file_list' in k:
					v = ensure_list(c[3][k])
					for l in v:
						file_lists[l] = read_file_list(os.path.join(path, l))
						platform_lists.setdefault(c[3]['target']+'/'+k, [])
						platform_lists[c[3]['target']+'/'+k] += v
						project_lists.setdefault(l, set())
						project_lists[l].add(c[3]['target'])
	output = 'start_sources()\r\n'
	for l in file_lists:
		output += "# -- "+l+" --\r\n"
		cond = generate_platform_condition([k for k in platform_lists if l in platform_lists[k]])
		if l.endswith('Scaleform/scaleform.waf_files'):
			cond = cond + " AND HAS_SCALEFORM"
		elif l.endswith('cryinput_orbis_shared.waf_files'):
			cond = cond + " AND HAS_ORBISPAD"
		output += "sources_platform(%s)\r\n" % cond
		for f in sorted(file_lists[l].keys()):
			output += 'add_sources("%s"\r\n' % f
			if any(len(project_lists[k]) != len(file_lists) for k in project_lists):
				output += '\tPROJECTS %s\r\n' % ' '.join(project_lists[l])
			for g in sorted(file_lists[l][f].keys()):
				output += '\tSOURCE_GROUP "%s"\r\n\t\t' % g.replace('/', "\\\\"*4)
				output += ('\r\n\t\t').join(['"%s"' % s for s in file_lists[l][f][g]])
				output += '\r\n'
			output += ')\r\n\r\n'
		for c in bld.collected:
			if c[0] == path and 'additional_manifests' in c[3]:
				output += "# -- Manifests --\r\n"
				v = ensure_list(c[3]['additional_manifests'])
				for m in v:
					output += 'configure_file(${CMAKE_CURRENT_SOURCE_DIR}/%s ${CMAKE_CURRENT_BINARY_DIR}/%s.manifest COPYONLY)\r\n' % (m, m)
				output += 'add_sources("NoUberFile" SOURCE_GROUP "Manifest"\r\n\t'
				output += ('\r\n\t').join(['"%s" "${CMAKE_CURRENT_BINARY_DIR}/%s.manifest"' % (m, m) for m in v])
				output += '\r\n)\r\n\r\n'

	output += "end_sources()\r\n"
	return output

def test_file_list(path):
	output = read_file_lists(path)
	print(output)
	f=open('test.txt', 'wb')
	f.write(output)
	f.close()

def _is_read_only(path):
	return not (os.stat(path)[0] & stat.S_IWRITE)

def update_file_list(path, dry_run):
	fname = os.path.join(path, 'CMakeLists.txt')
	f = open(fname, 'rb')
	old = f.read()
	f.close()
	output = read_file_lists(path)
	result = True
	# create regular expression pattern
	chop = re.compile('#START-FILE-LIST.*?#END-FILE-LIST', re.DOTALL)

	output = '#START-FILE-LIST\r\n' + \
		'# File List auto generated by waf2cmake.py, do not modify manually.\r\n\r\n' + \
		output + \
		'#END-FILE-LIST'

    # chop text between #chop-begin and #chop-end
	new = chop.sub(output, old)
	if not dry_run:
		if _is_read_only(fname):
			if _args.no_checkout:
				result = False
				os.chmod(fname, stat.S_IWRITE)
			else:
				try:
					FNULL = open(os.devnull, 'w')
					subprocess.call(['p4', 'edit', fname], stdout=FNULL)
					FNULL.close()
				except:
					pass
				if _is_read_only(fname):
					result = False
					os.chmod(fname, stat.S_IWRITE)
		f = open(fname, 'wb')
		f.write(new)
		f.close()
	elif _args.interactive:
		print(new)
	return result

def read_file_list(path):
	res = json.load(open(path))

	#Flatten nested lists
	processed = False
	while not processed:
		processed = True
		temp = {}
		for u in res:
			temp[u] = {}
			for g in res[u]:
				temp[u][g] = []
				for f in res[u][g]:
					if isinstance(f, dict):
						processed = False
						for g2 in f:
							if g+'/'+g2 in temp[u]:
								print("!!!"+g+'/'+g2)
							temp[u][g+'/'+g2] = f[g2]
					else:
						temp[u][g].append(f)
		res = temp
	return res

# http://stackoverflow.com/questions/279561
def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate

@static_vars(counter=0)
def progress_report(msg, end=False):
	if not _args.quiet:
		if not end:
			msg = "|/-\\"[progress_report.counter % 4] + " " + msg
			progress_report.counter += 1
			msg = msg[:79]
			print(msg + (" "*(79-len(msg))) + "\r", end='')
		else:
			print(msg + (" "*(79-len(msg))))

class BuildCollector(object):
	"""Emulates a WAF build context to gather data on all possible modules in the build."""
	def __init__(self):
		self.collected = []
		self.pathstack = []
		self.cmd = 'project_generator'
		self.env = ConfigSet.ConfigSet()
		self.options = BlackHole()

	def CreateRootRelativePath(self, p):
		return p

	def get_supported_platforms(self, *args, **kwargs):
		return ['darwin_x64', 'win_x86', 'win_x64', 'durango', 'orbis', 'android_arm_gcc', 'linux_x86_gcc', 'linux_x64_gcc', 'linux_x86_clang', 'linux_x64_clang']

	def recurse_subdirs(self, *args, **kwargs):
		path = os.path.join(*self.pathstack)
		subdirs = [x for x in os.listdir(path) if os.path.isdir(os.path.join(path, x))]
		self.recurse(subdirs)

	def recurse(self, folders, *args, **kwargs):
		if isinstance(folders, basestring):
			folders = [folders]
		for f in folders:
			self.pathstack.append(f)
			path = os.path.join(*self.pathstack)
			progress_report("Processing "+path)
			self.path = PathNode(path)
			if (os.path.isfile(path+'/wscript')):
				m = Context.load_module(path+'/wscript')
				def PathWrapper(p):
					return p
				def SettingsWrapper(*k, **kw):
					return (k, kw)
				m.Path = PathWrapper
				m.Settings = SettingsWrapper
				m.build(self)
			self.pathstack.pop()

	def __getattr__(self, name):
		return BuildObject(os.path.join(*self.pathstack), name, self)

	def spec_modules(self, *args, **kwargs):
		return self.pathstack[-1]

class BuildObject(object):
	"""Helper class used to capture module definitions."""
	def __init__(self, path, name, collector):
		self.path = path
		self.name = name
		self.collector = collector

	def __call__(self, *args, **kwargs):
		self.collector.collected.append((self.path, self.name, args, kwargs))

class BlackHole(object):
	"""No-op object used to suppress unimportant function calls.."""
	def __init__(self):
		pass

	def __getattr__(self, name):
		return self

	def __call__(self, *args, **kwargs):
		print(args, kwargs)
		return self

class PathNode(object):
	"""Emulates a WAF path node."""
	def __init__(self, p):
		self.p = p

	def make_node(self, p):
		return PathNode(os.path.join(self.p, p))

	def abspath(self):
		return os.path.abspath(self.p)
Logs.log = BlackHole()
_args = None
bld = BuildCollector()

def main():
	global _args
	parser = argparse.ArgumentParser(description="Converts WAF file lists to CMake.")
	parser.add_argument('-c', '--checkout', action='store_true', help=argparse.SUPPRESS) # Not used; is on by default now
	parser.add_argument('-n', '--no-checkout', action='store_true', help='Do not attempt to check out files to default p4 changelist (just clear read-only flag)')
	parser.add_argument('-q', '--quiet', action='store_true', help='Disable output')
	parser.add_argument('-m', '--missing', action='store_true', help='Show paths with wscript modules but no CMakeLists.txt')
	parser.add_argument('-p', '--paths', nargs='*', help='Extra directories to parse (default: Code/GameMono, Code/GameSDK, Code/GameZero)', metavar='PATH', default=['Code/GameMono', 'Code/GameSDK', 'Code/GameZero'])
	parser.add_argument('-d', '--dry-run', action='store_true', help="Don't change any files, only test what would happen")
	parser.add_argument('-i', '--interactive', action='store_true', help=argparse.SUPPRESS) # launches into a basic interactive prompt - default if sys.argv[0] does not contain "waf2cmake"
	parser.add_argument('-u', '--update', action='store_true', help=argparse.SUPPRESS) # update all, don't go into prompt - default if sys.argv[0] contains "waf2cmake"
	_args = parser.parse_known_args()[0]

	cmd_queue = []

	if 'waf2cmake' not in sys.argv[0] and not _args.missing and not _args.update:
		_args.interactive = True
	if not _args.interactive:
		if _args.missing:
			cmd_queue.append('m')
		else:
			cmd_queue.append('A')
		cmd_queue.append('q')
	else:
		_args.quiet = False

	bld.recurse(['Code', 'Engine'] + [os.path.normpath(a.strip()) for a in _args.paths])
	progress_report("Loaded %s modules." % len(bld.collected), True)

	while True:
		if cmd_queue:
			s = cmd_queue[0]
			cmd_queue=cmd_queue[1:]
		else:
			s = input('\n?')
		if not s or s == 'q':
			break
		if ' ' in s:
			cmd, arg = s.split(' ', 2)
		else:
			cmd, arg = s[0], s[1:]
		if cmd == '?':
			print("T <path>: Test file_list reading on wscript from <path> (default: XRenderD3D9)")
			print("u <path>: Test update based on wscript from <path> (default: XRenderD3D9)")
			print("U <path>: Update file list based on wscript from <path> (default: XRenderD3D9)")
			print("A: Update all file lists")
			print("t <target>: Print collected <target>")
			print("p <path>: Print wscript in directory ending with <path>")
			print("k <key>: Print target names that have a key with substring <key>")
			print("K <key>: Print targets that have a key with substring <key>")
			print("/ <v>: Print target names that have a key with substring <v>, or <v> is a value")
			print("f <v>: Print targets that have a key with substring <v>, or <v> is a value")
			print("m: Show paths with a wscript but no CMakeLists.txt")
			print("?: Show this help message")
			print("q/<blank>: quit")
			continue
		if cmd == 'T':
			p = 'Code\\CryEngine\\RenderDll\\XRenderD3D9'
			for c in bld.collected:
				if c[0].endswith(arg) and arg:
					p = c[0]
					break
			test_file_list(p)
			continue
		if cmd == 'u' or cmd == 'U':
			p = 'Code\\CryEngine\\RenderDll\\XRenderD3D9'
			for c in bld.collected:
				if c[0].endswith(arg) and arg:
					p = c[0]
					break
			update_file_list(p, cmd=='u')
			continue
		if cmd == 'A':
			lastPath = ''
			flagsChanged = False
			for c in sorted(bld.collected, key=lambda x: x[0]):
				if lastPath != c[0] and os.path.isfile(os.path.join(c[0],'CMakeLists.txt')):
					if not _args.quiet:
						print("Updating "+c[0])
					t = not update_file_list(c[0], _args.dry_run)
					flagsChanged = flagsChanged or t 
				lastPath = c[0]
			if flagsChanged:
				print("Note: One or more files had their read-only flag cleared. You may need to reconcile changes in your version control system.")

		if cmd == 'm':
			lastPath = ''
			for c in sorted(bld.collected, key=lambda x: x[0]):
				if lastPath != c[0] and not os.path.isfile(os.path.join(c[0],'CMakeLists.txt')):
					print(c[0])
				lastPath = c[0]
			continue
		for c in bld.collected:
			printColl = False
			printTarget = False
			if cmd == 't' and ('target' in c[3] and c[3]['target'] == arg):
				printColl = True
			if cmd == 'p' and (c[0].endswith(arg)):
				printColl = True
			if cmd == 'k' or cmd == 'K':
				for k in c[3]:
					if arg in k:
						if cmd == 'k':
							printTarget = True
						elif cmd == 'K':
							printColl = True
			if cmd == '/' or cmd == 'f':
				for k in c[3]:
					try:
						if arg in k or arg in c[3][k]:
							if cmd == '/':
								printTarget = True
							elif cmd == 'f':
								printColl = True
					except TypeError:
						pass
			if printColl:
				pprint.pprint(c)
			elif printTarget:
				print(c[3]['target'])

if __name__== '__main__':
	main()
